
Build scripts
=============

Scripts to compile and run Standard ML programs defined in .mlb files.

All of these are Bash scripts for Unixy systems, except for one
PowerShell script for Windows (see below).

The .mlb format is associated with the MLton compiler, and a .mlb file
can be built using MLton without any of these scripts by running

 $ mlton file.mlb
 $ ./file

But MLton is rather slow to run, for development use, and it's a good
idea to test code with more than one compiler.

The script "polybuild" therefore takes a .mlb file and builds an
executable from it using the Poly/ML compiler:

 $ polybuild file.mlb
 $ ./file

Note that if the .mlb file contains other .mlb files, the script
simply interpolates their content into the parent. This is not the way
.mlb files are supposed to work: each new .mlb is supposed to be
elaborated into a new empty environment, which is then brought into
the parent environment. This can cause incompatibilities in both
directions: programs that build with MLton but not polybuild, and also
vice versa. I haven't yet met an incompatibility that couldn't be
worked around though. (I think it's also possible to define programs
that build both ways but work differently, although I don't think this
is likely by accident.) Anyway, treat the MLton build as definitive.


Main function and top-level code
================================

Different compilers have different conventions for the main entry
points they generate in a stand-alone executable. MLton produces an
executable that, when run, invokes any code found at the top level
during compilation. Compilers such as Poly/ML, that start from an
interactive environment, usually run that code "at compile time"
instead. In place of that, Poly/ML expects to find a function called
"main" that it will make into the entry point for the executable.

The convention used by these scripts is that your program will have a
main.sml listed at the bottom of its .mlb file, and that main.sml will
simply call out (at the top level) to a main function that presumably
has already been defined in an earlier file of code. Thus main.sml
provides the entry point for MLton. Then the polybuild script will
*remove* any file called main.sml when it compiles for Poly/ML,
leaving the main function that this file would have called as the
entry point.


Build-and-run or build-and-REPL scripts
=======================================

The script "polyrun" takes a .mlb file and runs it directly in the
Poly/ML environment (rather than dumping out an executable as
polybuild does).

The script "polyrepl" takes a .mlb file and loads it into the Poly/ML
interactive environment (or REPL), leaving you at the REPL prompt.

The script "smlrun" takes a .mlb file and runs it directly using the
SML/NJ environment.

The PowerShell script "smlrun.ps1", for Windows, takes a .mlb file and
runs it directly using the SML/NJ environment.


Code coverage
=============

The script "mlb-coverage" uses MLton's profile tool to print out line
coverage reports for the files making up a program. Run

 $ ./mlb-coverage file.mlb

to compile and print an overall coverage summary for the program
defined in file.mlb, or

 $ ./mlb-coverage file.mlb sourcefile.sml

to compile file.mlb and print detailed coverage for the single source
file sourcefile.sml.


Dependencies
============

The script "mlb-dependencies" reads a .mlb file and prints to stdout a
list of file dependencies in Makefile format. This could be used to
generate a file that can be included into a project Makefile.

